「HarmonyPID」技術仕様書

1. はじめに

1.1. 目的とスコープ

本技術仕様書は、4D-Cシステムの中核コンポーネントであるHarmonyPIDクラスのアーキテクチャ、機能、および実装ロジックを詳細に定義するものです。本クラスは、システムの現在状態を目標値「0.89」（4D-C 臨界調和点）へと安定的かつ効率的に収束させるためのPID（比例・積分・微分）制御ロジックをカプセル化しています。

本文書では、クラスの内部構造、制御パラメータの役割、そしてシミュレーションによる具体的な動作例を解説します。これにより、開発者が本コンポーネントを正確に理解し、システムへ適切に統合・利用するための技術的基盤を提供することを目的とします。

2. HarmonyPID クラス仕様

2.1. 概要

HarmonyPIDは、古典的かつ堅牢な制御アルゴリズムであるPID制御を実装したPythonクラスです。その主な役割は、システムの現在値と目標値との誤差に基づき、システムを目標値に近づけるための最適な調整量を算出することです。本クラスの設計は、連続的なフィードバックが求められるリアルタイム制御ループ内での利用を想定しており、その応答性と安定性がシステム全体の性能を決定づけます。

クラスのdocstringに記された「4D-Cの心臓部：PID制御によるHarmony 0.89への収束ロジック」という記述は、本クラスがシステム全体において、調和（Harmony）を維持し、目標状態へ導くための中心的な役割を担っていることを象徴しています。

2.2. 初期化メソッド (__init__)

__init__メソッドは、HarmonyPIDクラスのインスタンス生成時に呼び出され、コントローラの動作を決定する制御パラメータと、計算に必要な内部状態変数を初期化する責務を持ちます。

2.2.1. 制御パラメータ

PIDコントローラの振る舞いは、3つの主要なゲインパラメータ（Kp, Ki, Kd）によって調整されます。これらのパラメータは、システムの特性に応じて最適な値に設定される必要があります。

パラメータ	デフォルト値	技術的役割
Kp	0.2	比例項ゲイン。 ソースコードのコメント「比例：目標への反応速度」が示す通り、現在の誤差に比例した制御量を生成します。値が大きいほど目標値への応答は速くなりますが、大きすぎると振動（ハンチング）を引き起こす可能性があります。
Ki	0.05	積分項ゲイン。 ソースコードのコメント「積分：蓄積した誤差の修正」の通り、過去の誤差の累積値（積分）に基づいて制御量を生成します。これにより、比例制御だけでは解消しきれない定常的な誤差（オフセット）を是正し、最終的に目標値に正確に一致させます。
Kd	0.1	微分項ゲイン。 ソースコードのコメント「微分：急激な変化へのブレーキ」が示す通り、誤差の変化率（微分）に反応します。システムの急激な変動を予測して抑制する働きを持ち、オーバーシュート（目標値を超過する動き）を防ぎ、システム全体の安定性を高めます。

2.2.2. 内部状態変数

インスタンスは、連続的な計算のために前回の状態を保持する必要があります。以下は、そのために使用される内部変数です。

変数名	初期値と目的
target	0.89（固定値）。制御目標であり、「4D-C 臨界調和点」として定義されています。
prev_error	0。前回のupdateメソッド呼び出し時の誤差を保存します。この値は、次回の呼び出し時に微分項を計算するために不可欠です。
integral	0。誤差の累積値を保持します。この値はupdateメソッドが呼び出されるたびに更新され、積分項の計算に使用されます。
last_time	time.time()。前回のupdateメソッドが呼び出された時刻を記録します。これにより、呼び出しごとの正確な経過時間(dt)を算出し、時間依存の積分項および微分項の精度を保証します。

2.3. 制御量更新メソッド (update)

updateメソッドは、HarmonyPIDクラスの心臓部と言える機能です。外部から現在のシステム値 (current_value) を引数として受け取り、内部でPIDアルゴリズムに基づいた一連の計算を実行し、システムに適用すべき最適な制御量 (output) を返却します。

2.3.1. インターフェース定義

本メソッドは以下のインターフェースで定義されます。

* 引数:
  * current_value (float): 制御対象の現在の測定値。
* 戻り値:
  * output (float): 計算された制御量（調整量）。

2.3.2. 内部処理ロジックの解析

updateメソッド内部では、以下のステップで制御量が計算されます。

1. 経過時間 (dt) の算出 now - self.last_time により、前回の呼び出しからの経過時間を秒単位で算出します。このdtは積分項と微分項の計算精度に直接影響します。万が一、dtが0以下になる（システムクロックの異常など）場合に備え、1e-6という微小値を設定することでゼロ除算エラーを回避する安全機構が組み込まれています。
2. 誤差 (error) の算出 self.target - current_value により、目標値と現在値との差分を計算します。このerrorが正であれば現在値が目標より低く、負であれば高いことを意味し、PID制御アルゴリズム全体の基本入力となります。
3. 積分項 (integral) の更新 self.integral += error * dt のロジックにより、誤差に経過時間を掛け合わせた値を累積していきます。これは時間に対する誤差の積分に相当し、過去からの誤差の蓄積を反映します。この項の働きにより、システムにわずかに残り続ける定常的な偏差を解消する効果が生まれます。
4. 微分項 (derivative) の算出 (error - self.prev_error) / dt のロジックにより、誤差の変化率を計算します。これは、誤差がどのくらいの速さで変化しているかを示しており、システムの未来の振る舞いを予測する役割を果たします。急激な変化に対してブレーキをかけるように作用し、振動を抑制して収束を滑らかにします。
5. 出力 (output) の合成 最終的な制御量は、以下の式で合成されます。
6. 算出された比例（P）、積分（I）、微分（D）の各項に対して、それぞれ設定されたゲイン (Kp, Ki, Kd) で重み付けを行い、それらをすべて足し合わせることで、システムに適用すべき最適な調整量が決定されます。
7. 状態の更新 計算の最後に self.prev_error = error と self.last_time = now を実行します。これにより、今回の計算で使用した誤差と時刻が「前回の値」として保存され、次回のupdate呼び出しに備えます。

これらのロジックが連携することで、HarmonyPIDはシステムの現在状態と変化の傾向を総合的に判断します。比例項（P）が誤差に対して即応的な制御を行い、積分項（I）が過去の誤差の蓄積から定常偏差を粘り強く解消し、微分項（D）が未来の誤差を予測して過剰な反応を抑制します。この三位一体の制御により、目標値に対して滑らかかつ安定的に収束させるための精密な制御が実現されます。

3. 実装・実行例

3.1. run_simulation 関数の役割

run_simulation関数は、HarmonyPIDクラスの動的な振る舞いを実証し、その有効性を視覚的に確認するために提供されるデモンストレーションプログラムです。この関数は、システムの調和度（current_harmony）が0.1という初期状態から、外部ノイズが存在する環境下で目標値0.89へと収束していく過程をリアルタイムにシミュレートします。シミュレーション開始時に、コンソールには --- 4D-C Core System Starting --- と目標値 Target Harmony: 0.89 が表示され、制御の目的を明確に示します。これにより、コントローラの応答性や安定性を直感的に理解することが可能となります。

3.2. シミュレーションロジックの解説

シミュレーションは、以下のステップで実行されます。

1. 初期化 まずcore = HarmonyPID()としてHarmonyPIDコントローラのインスタンスを生成します。同時に、制御対象であるシステムの初期状態をcurrent_harmony = 0.1に設定し、低い調和度からシミュレーションを開始します。
2. 無限ループ while Trueループ構文は、時間と共に連続的に変化するシステムの制御プロセスを模倣します。このループ内で、制御と状態更新が繰り返し実行されます。
3. 外部ノイズの導入 noise = (random.random() - 0.5) * 0.05 のコードは、現実世界のシステムが常に直面する予測不可能な外乱を擬似的に生成します。これが現実世界の予測不可能な外乱や、ソースコードで言及されている「クローナー」の影響を模倣しており、PIDコントローラが外乱に対してどれだけ堅牢に動作できるかを試すことができます。
4. 制御量の取得と状態更新 シミュレーションの中核をなす処理です。adjustment = core.update(current_harmony)を呼び出し、現在の調和度を基にPIDコントローラに最適な調整量を計算させます。その後、current_harmony += adjustment + noiseとして、計算された調整量と外部ノイズを現在の状態値に加算し、次の時点でのシステムの状態を更新します。
5. 状態の可視化 ソースコードのコメントで「鼓動」と表現されているように、現在の調和度の数値 ({current_harmony:.4f}) と、その大きさを█記号の長さで視覚的に表現したバーグラフをコンソールに出力します。これにより、ユーザーはシステムが目標値に近づいていく動的な振る舞いをリアルタイムで監視できます。
6. 収束判定 if abs(current_harmony - 0.89) < 0.001:の条件式は、現在の調和度が目標値0.89に十分近づいた（誤差が0.001未満になった）ことを検知します。この条件が満たされると、収束したことを示す特別なメッセージ「>>> 0.89 SYNC: The Silence is Here.」が出力されます。
7. シミュレーションの中断 シミュレーションはtry...exceptブロック内で実行されており、ユーザーが Ctrl+C を押下することで安全に中断できます。その際には --- 4D-C Core System Suspended --- というメッセージが表示され、システムが一時停止したことを示します。

このシミュレーション全体を通して、HarmonyPIDクラスが実際にどのように機能し、不安定な要素を含むシステムを目標状態へと導くかという実用的な使用方法が具体的に示されています。これは、本クラスを理解し、応用するための優れたサンプルコードです。

4. ライセンス

ソースコード末尾のSPDX-License-Identifier: MITという記述に基づき、本ソフトウェアコンポーネントはMITライセンスの下で提供されます。これにより、本ソフトウェアは、著作権表示を保持することを条件に、誰でも無償で、使用、複製、変更、結合、出版、配布、サブライセンス、および/または販売することが許可されます。
